#!/boot/rc
# rootless environment startup and launcher script by mycroftiv
# 9front version liberally copied from 9/boot/bootrc

if(~ $#rootdir 0)
	rootdir=/root
objtype=`{cat /env/cputype}

##	UTILITY FUNCTIONS ##

fn shifter{
	shift
	echo $*
}

fn getans{
	query=$1
	value=`{shifter $*}
	echo '* '$"query' = '$"value' : accept, new value, '''clear'''', or '''rc'''
#	answer=`{read}
	answer=`{dd -bs 64 -count 1 >[2]/dev/null}
	switch($answer){
	case rc
		rc -i
		getans $query $value
	case clear
		$query = ''
	case ?*
		$query = $answer
	case ''
		$query = $value
	}
}

##	ENVIRONMENT CHECKING FUNCTIONS ##

fn findpart{
	if((test -e /boot/sed) || (test -e /bin/sed)){
		if(~ $bootparse(1) *dev*){
			echo $bootparse(1) |sed 's/^local!//'
		}
		if not{
			echo $bootparse(1) |sed 's/^local!#./\/dev/'
		}
	}
	if not {
		if(~ $bootparse(1) *sdC0/$1)
			echo /dev/sdC0/$1
		if(~ $bootparse(1) *sdC1/$1)
			echo /dev/sdC1/$1
		if(~ $bootparse(1) *sdD0/$1)
			echo /dev/sdD0/$1
		if(~ $bootparse(1) *sdD1/$1)
			echo /dev/sdD1/$1
		if(~ $bootparse(1) *sdXX/$1)
			echo /dev/sdXX/$1
	}
}

fn hostcheck{
	hosttest=`{cat /dev/hostowner}
	if(~ $hosttest ''){
		if(~ $user ''){
			user=bootes
		}
		echo 'no hostowner found: setting to '$user
		echo -n $user >'/dev/hostowner'
	}
	if(~ $user ''){
		user=`{cat /dev/hostowner}
	}
}

fn dochecksys{
	systest=`{cat /dev/sysname}
	switch($sysname){
	case ?*
		if(~ $systest ''){
			echo setting /dev/sysname to $sysname
			echo -n $sysname >/dev/sysname
			systest=`{cat /dev/sysname}
		}
		if(! ~ $systest $sysname){
			echo warning sysname mismatch between dev and env
		}
	case ''
		if(~ $systest ''){
			if(~ $service cpu){
				sysname=helix
			} 
			if(~ $service terminal){
				sysname=gnot
			}
			if(~ $sysname ''){
				sysname=mutant
			}
			echo no sysname found in dev or env setting to $sysname
			echo -n $sysname >/dev/sysname
		}
		if not{
			echo setting sysname var to $systest from /dev/sysname
			sysname = $systest
		}
	}
}

##	STARTUP ACTION FUNCTIONS ##

fn doramsetup{
	switch($ramsetup){
	case ''
		echo no ramsetup
	case ?*
		hostcheck
		echo 'ramsetup '^$ramsetup^'...'
		rc -c $ramsetup
	}
}

fn dofactotum{
	if(~ $interactive yes)
		spc=()
	switch($factotum){
	case ''
		echo no factotum
	case cpu
		echo $spc cpu factotum...
		factotum $factotumopts -S -s factotum
	case terminal
		echo $spc terminal factotum...
		factotum $factotumopts -u -s factotum
	case debug
		hostcheck
		echo $spc debug factotum...
		factotum $factotumopts -d -s factotum
	}
}

fn dotryusb{
	if(! ~ $tryusb no){
		if (test -e /dev/usb/ctl) {
#			usbd /srv/usb
#			sleep 3
			if(test -e /dev/sdU0.0){
				if(! ~ $sdB0part ''){
					echo usb disk partfs -p $sdB0part -s partfs.sdXX /dev/sdU0.0
					partfs -p $sdB0part -s partfs.sdXX /dev/sdU0.0
					chmod 666 /srv/partfs.sdXX
				}
				if not
					echo /dev/sdU0.0 exists but no bootpartition information found
			}
		}
	}
}

fn ipsetup{
	if(! test -e /net/ipifc/0/ctl){
		if(~ $gateway ?*){
			ipparams=( -g $gateway ether /net/ether0 $ipaddress $ipmask )
		}
		echo ipconfig $ipparams
		ipconfig $ipparams
		ipconfig loopback /dev/null 127.1
	}
	ipdone=yes
}

fn doafterfact{
	switch($afterfact){
	case ?*
		echo after factotum command $afterfact
		rc -c $afterfact
	case ''
		if(! ~ $privpassword ''){
			echo adding key to factotum
			if(~ $passdom '')
				passdom=9front
			if(~ $keyowner '')
				keyowner=$user
			echo 'key proto=p9sk1 dom='$passdom' user='$keyowner' !password='^$privpassword >/mnt/factotum/ctl
			rm /env/privpassword
			rm /env/passdom
			rm /env/keyowner
		}
	}
}

fn dostartventi{
	switch($startventi){
	case yes
		echo starting venti
		if(! ~ $ipdone yes){
			ipsetup
		}
		venti -c $venticonf -a $ventilisten -h $vhttplisten
		venti=tcp!127.1!17034
	case later
		echo ok you can start venti later that is fine
	}
}

fn dogetrootfs{
	switch($getrootfs){
	case hjfs
		bootpartition=`{findpart fs}
		if(~ $interactive yes){
			echo 'parsed hjfs bootpartition as ' $bootpartition ' enter new value if this is incorrect'
			getans bootpartition $bootpartition
		}
		if not if(~ $bootpartition ''){
			echo 'no bootpartition found, trying /dev/sdC0/fs as default'
			bootpartition=/dev/sdC0/fs
		}
		hjfs=$bootpartition
		{hjfs -s -f $bootpartition &} | echo 0 >/srv/boot
		bootsrv=/srv/boot		
	case cwfs
###		{$1 -s -f $*(2-) &} <[0=1] | echo 0 >/srv/boot
#		echo '{cwfs64x -s -f /dev/sdC0/fscache &} | echo 0 >/srv/boot'
#		{cwfs64x -s -f /dev/sdC0/fscache &} | echo 0 >/srv/boot
		bootpartition=`{findpart fscache}
		if(~ $interactive yes){
			echo 'parsed cwfs bootpartition as ' $bootpartition ' enter new value if this is incorrect'
			getans bootpartition $bootpartition
		}
		if not if(~ $bootpartition ''){
			echo 'no bootpartition found, trying /dev/sdC0/fscache as default'
			bootpartition=/dev/sdC0/fscache
		}
		cwfs=$bootpartition
		{cwfs64x -s -f $bootpartition &} | echo 0 >/srv/boot
		bootsrv=/srv/boot
	case tcp
		if(! ~ $ipdone yes){
			ipsetup
		}
		if(~ $fs ''){
			echo 'fs is [ ' $fs ' ]?'
			getans fs $fs
		}
		if(~ $auth '')
			auth=$fs
## HACK: on terminals start new factotum that knows where to dial
		if(~ $factotum terminal)
			factotum -a $auth
		if(~ $cfs ''){
			echo srv $fs to /srv/boot...
			if(~ $fs tcp*)
				srv $fs boot
			if not
				srv tcp!$fs!564 boot
			bootsrv=/srv/boot
		}
		if not{
			echo starting cfs $cfs dialing $fs and serving root to /srv/boot...
			if(~ $fs tcp*)
				cfs -a $fs -f $cfs -z boot
			if not
				cfs -a tcp!$fs!564 -f $cfs -z boot
			bootsrv=/srv/boot
		}
	case local
		if(~ $kfs ''){
			if(! ~ $fossil ?*){
				bootpartition=`{findpart fossil}
				if(~ $interactive yes){
					echo 'parsed fossil bootpartition as ' $bootpartition ' enter new value if this is incorrect'
					getans bootpartition $bootpartition
				}
				if not if(~ $bootpartition ''){
					echo 'no bootpartition found, trying /dev/sdC0/fossil as default'
					bootpartition=/dev/sdC0/fossil
				}
				fossil=$bootpartition
			}
			if(! ~ $venti ''){
				if(! ~ $ipdone yes){
					ipsetup
				}
			}
			echo starting fossil from $fossil...
			fossil -f $fossil -c 'srv -p fscons'
			echo 'srv -A boot' >>/srv/fscons
			bootsrv=/srv/boot
			bootpartition=$fossil
		}
		if not{
			if(~ $interactive yes){
				echo 'kfs parsed as ' $kfs ' enter new value if this is incorrect'
				getans kfs $kfs
			}
			if(! ~ $bootparse(2) '')
				kfsparams=`{shifter $bootparse}
			echo kfs -f $kfs -n boot $kfsparams
			kfs -f $kfs -n boot $kfsparams
			bootsrv=/srv/kfs.boot
			bootpartition=$kfs
		}
	case srv
		if(~ $interactive yes){
			echo 'enter full path to target srv'
			getans bootsrv $bootsrv
		}
	case ''
		echo no standard root fs attached
	}
}

fn doafterroot{
	switch($afterroot){
	case ?*
		echo afterroot command $afterroot
		rc -c $afterroot
	case ''
		echo -n ''
	}
}

fn doinitscript{
	switch($initscript){
	case ?*
		newns -n /boot/$namespace $initscript
	case easteregg
		echo guess i should make an easter egg here
	}
}

fn dorootstart{
	switch($rootstart){
	case grid
		service=cpu
		echo grid service started mounting $bootsrv and starting hubrc
		mount $bootsrv /root
		if(test -e /root/rc/bin/hubrc)
			newns -n /root/lib/namespace /root/rc/bin/hubrc
		if not{
			echo no hubrc found trying defaults
			ndb/cs
			import -c $hubserver / /n/$hubserver
			mount -c /n/$hubserver/srv/gridhub /n/gridhub
			echo 'attaching to '$hubserver' gridhub'
			if(test -e /n/gridhub/^$sysname^0){
				echo 'attaching rc to existing clonecpu hubs'
				rc -i </n/gridhub/^$sysname^0 >>/n/gridhub/^$sysname^1 >>[2]/n/gridhub/^$sysname^2 &
			}
			hub gridhub $sysname
		}
	case cpu
		service=cpu
		echo mounting $bootsrv to /root and starting cpurc
		mount $bootsrv /root
		if(test -e /root/rc/bin/cpurc)
			newns -n /root/lib/namespace /root/rc/bin/cpurc
		if not
			echo ERROR no cpurc found
	case terminal
		service=terminal
		echo mounting $bootsrv to /root and starting termrc
		mount $bootsrv /root
		if(~ $user ''){
			user=`{cat /dev/hostowner}
		}
		home=/usr/$user
		if(test -e /root/rc/bin/termrc){
			newns -n /root/lib/namespace /root/rc/bin/termrc
			newns -n /root/lib/namespace rc -c 'cd; . $home/lib/profile'
		}
		if not
			echo ERROR no termrc found
	case ''
		echo not starting externally rooted startup scripts
	}
}

############# End of fn definitions #################
############# Begin script execution ###############

echo 'ROOTLESS PLAN 9 NAMESPACE LAUNCHER'

bind -q '#p' /proc
for(i in S f k Ã¦ t b m)
	bind -qa '#'^$i /dev

# bind in an ip interface
for(i in I l^(0 1 2 3))
	bind -qa '#'$i /net

cat '#r/rtc' >/dev/time >[2]/dev/null

##	if we have a paqfs set it up in both boot and bin

if(test -e /boot/bootpaq){
	echo -n paqfs...
	paqfs -s -S bootpaq -c 256 /boot/bootpaq
	mount -a /srv/bootpaq /boot
	bind -a /boot /bin
}

mntgen -s slash /mnt
bind /root /mnt/broot
unmount /root

# keyboard and serial console
if(test -x /bin/aux/kbdfs){
	a=$console(1)
	if(! ~ $#a 0)
		a=/dev/eia^$a
	aux/kbdfs -q -s cons $a
}

# usb devices
if(test -x /bin/nusbrc && ! test -e /env/nousbrc)
	nusbrc

# wait for devices to settle down
if(~ $#usbwait 1)
	sleep $usbwait
if(~ $#usbwait 0)
	sleep 2

diskparts

##	Parse plan9.ini options and trying to set sane defaults ##

if(! ~ $1 '')
	. $1
if(~ $bootargs ''){
	bootargs='local!#S/sdC0/fossil'
	interactive=yes
	echo 'no bootargs found using '$bootargs' and setting interactive=yes'
}
factotumopts=`{echo $factotumopts}
bootparse=`{echo $bootargs}
if(~ $bootparse(1) local*)
	getrootfs=local
if(~ $bootparse(1) *fs)
	getrootfs=hjfs
if(~ $bootparse(1) *fscache)
	getrootfs=cwfs
if(~ $bootparse(1) tcp*){
	getrootfs=tcp
	if(! ~ $bootparse(2) '')
		ipparams=`{shifter $bootparse}
}
if(~ $bootparse(1) srv*)
	getrootfs=srv
if(~ $bootparse(1) *fs){
	if(~ $kfs ''){
		kfs=`{findpart fs}
	}
}
if(~ $ramsetup '')
	ramsetup=ramskel
if(~ $initscript '')
	initscript=initskel
#if(~ $tgzfs '')
#	tgzfs=tools.tgz
if(~ $namespace '')
	namespace=namespace
if(~ $factotum '')
	factotum=`{cat '/env/service'}
if(~ $rootstart '')
	rootstart=`{cat '/env/service'}
ventiparse=`{echo $venti}
venticonf=$ventiparse(1)
ventilisten=$ventiparse(2)
vhttplisten=$ventiparse(3)
if(~ $venticonf '#'*)
	startventi=yes
if(~ $venticonf '')
	venticonf=/dev/sdC0/arenas
if(~ $ventilisten '')
	ventilisten=tcp!*!17034
if(~ $vhttplisten '')
	vhttplisten=tcp!127.1!8000
if(~ $interactive '')
	interactive=traditional

##	INTERACTIVE STARTUP PROMPTS AND ACTIONS ##

fn startinter{
	echo Interactive Startup - enter to continue to options or type rc for a shell
	answer=`{read}
	if(~ $answer rc){
		echo dropping to rc shell with limited commands
		rc -i
	}
	echo 'Internet config DHCP by default. Enter ipconfig parameters if needed'
	getans ipparams $ipparams
	echo 'Choose factotum mode - cpu terminal or debug.'
	getans factotum $factotum
	dofactotum
	dotryusb
	echo 'Enter sysname'
	getans sysname $sysname
	echo 'Skeleton fs required for mountpoints. Default ramskel recommended.'
	getans ramsetup $ramsetup
	echo 'Load optional tools from 9fat? Enter tools.tgz or other if desired'
	getans tgzfs $tgzfs
	doramsetup
	hostcheck
	dochecksys
	echo 'Start local Venti? Enter yes if so.'
	getans startventi $startventi
	if(~ $startventi yes){
		echo 'enter venti listen string'
		getans ventilisten $ventilisten
		echo 'enter venti httplisten string'
		getans vhttplisten $vhttplisten
	}
	dostartventi
	echo 'Attach to a file server? Choose local or tcp or leave blank for none.'
	getans getrootfs $getrootfs
	if(~ $getrootfs tcp){
		echo 'fileserver is [ ' $fs ' ]?'
		getans fs $fs
		echo 'auth is [ ' $auth ' ]?'
		getans auth $auth
		echo 'cfs is [ ' $cfs ' ]?'
		getans cfs $cfs
	}
	if(~ $getrootfs local){
		echo 'Dial a venti server? Enter a dialstring or ip if so.'
		getans venti $venti
		if(! ~ $venti ''){
			if(! ~ $venti tcp*)
				venti=tcp!^$venti^!17034
		}
		if(~ ! venti ''){
			ipsetup
		}
	}
	dogetrootfs
	echo 'Create cpu server namespace on a port of your choice? Initskel if so.'
	getans initscript $initscript
	doinitscript
	echo 'Start cpurc termrc from the file server? Enter cpu or terminal if so.'
	getans rootstart $rootstart
	dorootstart
	echo '#c' `{cat '#c/user'} `{cat '#c/sysname'} /env $user $sysname
	echo 'Keep console in ramboot namespace? yes if so.'
	getans staylocal $staylocal
	echo 'storing startup configuration to ramdisk in /usr/'$user'/tmp/p9cfg'
	save9cfg
	if(! ~ $staylocal no){
		echo starting mntgen and shell in current namespace
		home=/usr/$user
		mntgen
		rc -i
	}
}

##	TRADITIONAL STARTUP PROMPTS AND ACTIONS ##

fn starttrad{
	dofactotum
	dotryusb
	doramsetup
	hostcheck
	dochecksys
	doafterfact
	echo -n 'root is from (tcp,local)['$bootargs']: '
	bootanswer=`{read}
	if(~ $bootanswer rc){
		rc -i
	}
	if not if(! ~ $bootanswer ''){
		bootparse=`{echo $bootanswer}
	}
	if not{
		bootparse=`{echo $bootargs}
	}
	if(~ $bootparse(1) local*)
		getrootfs=local
	if(~ $bootparse(1) *fs)
		getrootfs=hjfs
	if(~ $bootparse(1) *fscache)
		getrootfs=cwfs
	if(~ $bootparse(1) tcp*){
		getrootfs=tcp
		if(! ~ $bootparse(2) '')
			ipparams=`{shifter $bootparse}
	}
	if(~ $bootparse(1) srv*)
		getrootfs=srv
	if(~ $getrootfs tcp){
		echo 'fileserver is [ ' $fs ' ]?'
		getans fs $fs
		echo 'auth is [ ' $auth ' ]?'
		getans auth $auth
	}
	dostartventi
	interactive=yes
	dogetrootfs
	interactive=traditional
	doafterroot
	doinitscript
	dorootstart
#	echo '#c' `{cat '#c/user'} `{cat '#c/sysname'} /env $user $sysname
	echo 'storing startup configuration to ramdisk in /usr/'$user'/tmp/p9cfg'
	save9cfg
	if(! ~ $staylocal no){
		echo starting mntgen and shell in current namespace
		home=/usr/$user
		mntgen
		rc -i
	}
}

##	NON-INTERACTIVE STARTUP ACTIONS ##

fn startnonint{
	dofactotum
	dotryusb
	doramsetup
	hostcheck
	dochecksys
	doafterfact
	dostartventi
	dogetrootfs
	doafterroot
	doinitscript
	dorootstart
#	echo '#c' `{cat '#c/user'} `{cat '#c/sysname'} /env $user $sysname
	echo 'storing startup configuration to ramdisk in /usr/'$user'/tmp/p9cfg'
	save9cfg
	if(! ~ $staylocal no){
		echo starting mntgen and shell in current namespace
		home=/usr/$user
		mntgen
		rc -i
	}
}

if(~ $interactive yes){
	@{startinter}
} </dev/cons
if not if(~ $interactive traditional){
	@{starttrad}
} </dev/cons
if not {
	@{startnonint}
} </dev/cons

echo 'startup scripts exited!! starting recovery rc'
while(){
	@{rc}
} </dev/cons

exit ''

